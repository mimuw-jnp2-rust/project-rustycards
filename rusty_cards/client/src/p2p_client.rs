use std::{
    io::{self, Read},
    net::{SocketAddr, TcpListener, TcpStream},
    option::Option,
    str::FromStr,
    sync::atomic::{AtomicBool, Ordering},
};

use crate::action::{self, Action};
use crate::game;
use crate::utils;
use rusty_cards::Handshake;

pub struct Client {
    server: SocketAddr,
    listener: TcpListener,
    going_first: AtomicBool,
}

impl Default for Client {
    fn default() -> Self {
        println!("Providing default values for client...");
        let server = Self::default_server();
        let listener = Self::default_listener();
        Client {
            server,
            listener: TcpListener::bind(listener).unwrap(),
            going_first: AtomicBool::new(false),
        }
    }
}

impl Client {
    pub fn new(server: SocketAddr, listener: SocketAddr) -> Self {
        Client {
            server,
            listener: TcpListener::bind(listener).unwrap(),
            going_first: AtomicBool::new(false),
        }
    }

    pub fn default_server() -> SocketAddr {
        println!("Binding server socket to default: 127.0.0.1:8888");
        SocketAddr::from_str("127.0.0.1:8888").unwrap()
    }

    pub fn default_listener() -> SocketAddr {
        println!("Binding listener to default: 127.0.0.1:8080");
        SocketAddr::from_str("127.0.0.1:8080").unwrap()
    }

    pub fn start(&self) -> io::Result<()> {
        println!("Looking for an opponent");
        let mut game_state = game::GameState::new();
        let opponent_stream: Option<TcpStream> = self.find_opponent(&mut game_state);
        if opponent_stream.is_none() {
            panic!("Opponent stream is set to None. Unexpected behaviour!");
        }
        println!("Ready to start the game :>");

        let mut opponent_stream = opponent_stream.unwrap();
        if self.going_first.load(Ordering::Relaxed) {
            println!("Starting the game...");
            let start_game: Action = Action::Start("Worthy opponent :3".to_string());
            match utils::send_msg(&mut opponent_stream, start_game) {
                Ok(()) => println!("Game beggins!"),
                Err(e) => println!("Connection failed T^T\nError: {e}"),
            }
        } else {
            println!("Waiting for the opponent to start the game...");
            let mut buffer = [0; 1024];
            let mut num_bytes = 0;
            while num_bytes == 0 {
                num_bytes = opponent_stream.read(&mut buffer).unwrap();
            }

            let game_beggins: Action = serde_json::from_slice(&buffer[..num_bytes]).unwrap();
            match game_beggins {
                Action::Start(greet) => println!("Game beggins! {greet}"),
                // For now cannot be reached, but later there is a plan to extend Action enum
                _ => println!("Connection failed T^T"),
            }
        }
        self.proceed_game(opponent_stream, game_state);
        println!("The game ends :] GG");
        Ok(())
    }

    // Sends a message to a server with socket address
    // The response from the server is always one of the follwing:
    //      1. Wait, along with the password generated by the server
    //          It indicates that we should wait on a socket that we
    //          provided for the opponents message that will contain
    //          the password from the server
    //      2. Send, along with the opponents socket address and password
    //          It indicates that we should send a message with a password
    //          and the opponent will wait for this message on the socket
    //          address that we have received
    pub fn find_opponent(&self, game_state: &mut game::GameState) -> Option<TcpStream> {
        let mut server_stream = TcpStream::connect(self.server).unwrap();
        let connection_established: bool = false; // this should never change
        while !connection_established {
            println!("Sending listener address to the server.");
            let listener_address = self.listener.local_addr().ok()?;
            let ready_msg = Handshake::Ready(listener_address);
            utils::send_msg(&mut server_stream, ready_msg).ok()?;

            println!("Waiting for an opponent...");
            let mut buffer = [0; 4096];
            let mut num_bytes = 0;
            while num_bytes == 0 {
                num_bytes = server_stream.read(&mut buffer).unwrap();
            }

            println!("Opponent appeared. Trying to establish connection...");
            let server_response: Handshake = serde_json::from_slice(&buffer[..num_bytes]).unwrap();
            match server_response {
                Handshake::Send(addr, password, gs) => match self.received_send(addr, password) {
                    Some(s) => {
                        *game_state = gs;
                        return Some(s);
                    }
                    None => continue,
                },
                Handshake::Wait(password, gs) => match self.received_wait(password) {
                    Some(s) => {
                        *game_state = gs;
                        return Some(s);
                    }
                    None => continue,
                },
                _ => {
                    println!("Incorrect message from server. Retrying to find opponent...");
                    continue;
                }
            }
        }
        panic!("Opponent not found. This should never be reached!");
    }

    // Function that provides steps for the player who received Send message from the server
    pub fn received_send(&self, addr: SocketAddr, password: String) -> Option<TcpStream> {
        self.going_first.store(true, Ordering::Relaxed); // This player goes first

        println!("Sending {password} to the {addr}, to establish connection.");
        let mut opponent_stream: TcpStream = TcpStream::connect(addr).unwrap();
        let msg = Handshake::P2P(password.clone());
        match utils::send_msg(&mut opponent_stream, msg) {
            Ok(()) => println!("Message sent successfully!"),
            Err(e) => {
                println!("Couldn't send the message due to error {e}.");
                return None;
            }
        }

        println!("Waiting for the confirmation from the opponent...");
        let mut buffer = [0; 1024];
        let mut num_bytes = 0;
        while num_bytes == 0 {
            num_bytes = opponent_stream.read(&mut buffer).unwrap();
        }

        let confirmation: Handshake = serde_json::from_slice(&buffer[..num_bytes]).unwrap();
        if confirmation != Handshake::P2P(password.clone()) {
            println!("Faild to confirm the connection. Retrying to find opponent...");
            return None;
        }

        println!("Connection established!");
        return Some(opponent_stream);
    }

    // Function that provides steps for the player who received Wait message from the server
    pub fn received_wait(&self, password: String) -> Option<TcpStream> {
        self.going_first.store(false, Ordering::Relaxed); // this player goes second

        println!("Waiting for the {password} to establish connection...");
        for stream in self.listener.incoming() {
            println!("New stream appeared.");
            let mut stream = stream.unwrap();
            let mut buffer = [0; 1024];
            let mut num_bytes = 0;
            while num_bytes == 0 {
                num_bytes = stream.read(&mut buffer).unwrap();
            }

            let msg: Handshake = serde_json::from_slice(&buffer[..num_bytes]).unwrap();
            if msg != Handshake::P2P(password.clone()) {
                println!("Unexpected message. Waiting for different stream.");
                continue;
            }
            println!("Received message from the opponent! Sending confirmation.");

            let confirmation: Handshake = Handshake::P2P(password);
            match utils::send_msg(&mut stream, confirmation) {
                Ok(()) => println!("Confirmation sent!"),
                Err(e) => {
                    println!(
                        "Couldn't send the confirmation due to error {e}. Retrying to find opponent..."
                    );
                    return None;
                }
            }

            println!("Connection established!");
            return Some(stream);
        }
        return None; // Should never be reached
    }

    pub fn proceed_game(&self, mut opponent_stream: TcpStream, mut game_state: game::GameState) {
        game_state.begin();
        loop {
            action::perform_action(&mut game_state);
        }
    }
}
